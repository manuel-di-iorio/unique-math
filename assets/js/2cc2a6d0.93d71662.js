"use strict";(globalThis.webpackChunkuniquemath=globalThis.webpackChunkuniquemath||[]).push([[332],{6908:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>h,contentTitle:()=>c,default:()=>x,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Struct/UeSphere","title":"UeSphere","description":"A bounding sphere defined by a center point and a radius. Useful for spatial queries, collision detection, and bounding volume hierarchies in 3D.","source":"@site/docs/Struct/UeSphere.md","sourceDirName":"Struct","slug":"/Struct/UeSphere","permalink":"/unique-math/docs/Struct/UeSphere","draft":false,"unlisted":false,"editUrl":"https://github.com/manuel-di-iorio/unique-math/tree/main/docs/docs/Struct/UeSphere.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"documentationSidebar","previous":{"title":"UeBox3","permalink":"/unique-math/docs/Struct/UeBox3"},"next":{"title":"UeFrustum","permalink":"/unique-math/docs/Struct/UeFrustum"}}');var d=s(4848),n=s(8453);const i={sidebar_position:11},c=void 0,h={},o=[{value:"Constructor",id:"constructor",level:2},{value:"Data parameters",id:"data-parameters",level:3},{value:"Methods",id:"methods",level:2}];function l(e){const r={code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(r.p,{children:"A bounding sphere defined by a center point and a radius. Useful for spatial queries, collision detection, and bounding volume hierarchies in 3D."}),"\n",(0,d.jsx)(r.hr,{}),"\n",(0,d.jsx)(r.h2,{id:"constructor",children:"Constructor"}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-js",children:"new UeSphere(center = new UeVector3(0, 0, 0), radius = -1)\n"})}),"\n",(0,d.jsx)(r.h3,{id:"data-parameters",children:"Data parameters"}),"\n",(0,d.jsxs)(r.table,{children:[(0,d.jsx)(r.thead,{children:(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.th,{children:"Name"}),(0,d.jsx)(r.th,{children:"Type"}),(0,d.jsx)(r.th,{children:"Default"}),(0,d.jsx)(r.th,{children:"Description"})]})}),(0,d.jsxs)(r.tbody,{children:[(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"center"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"UeVector3"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"(0, 0, 0)"})}),(0,d.jsx)(r.td,{children:"Center point of the sphere"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"radius"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"number"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"-1"})}),(0,d.jsx)(r.td,{children:"Radius of the sphere; < 0 means empty"})]})]})]}),"\n",(0,d.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsxs)(r.table,{children:[(0,d.jsx)(r.thead,{children:(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.th,{children:"Method"}),(0,d.jsx)(r.th,{children:"Returns"}),(0,d.jsx)(r.th,{children:"Description"})]})}),(0,d.jsxs)(r.tbody,{children:[(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"set(center, radius)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Sets the center and radius of the sphere"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"copy(sphere)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Copies values from another sphere"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"clone()"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"UeSphere"})}),(0,d.jsx)(r.td,{children:"Returns a new copy of this sphere"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"isEmpty()"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"boolean"})}),(0,d.jsxs)(r.td,{children:["Returns ",(0,d.jsx)(r.code,{children:"true"})," if radius is less than 0 (sphere is empty)"]})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"makeEmpty()"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Makes the sphere empty"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"containsPoint(point)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"boolean"})}),(0,d.jsxs)(r.td,{children:["Returns ",(0,d.jsx)(r.code,{children:"true"})," if the point is inside or on the surface (point: UeVector3)"]})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"distanceToPoint(point)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"number"})}),(0,d.jsx)(r.td,{children:"Returns distance from the surface to a point (negative if inside) (point: UeVector3)"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"clampPoint(point, target)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"UeVector3"})}),(0,d.jsx)(r.td,{children:"Clamps a point inside the sphere boundary (point: UeVector3)"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"applyMatrix4(matrix)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Applies a 4x4 transformation matrix to the sphere"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"expandByPoint(point)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Expands the sphere to include the given point (point: UeVector3). If sphere is empty, sets center to point and radius to 0."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"setFromPoints(points, optionalCenter)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Sets the sphere from an array of points (array of UeVector3 or flat array [x0,y0,z0,x1,y1,z1,...]), optionally with a center"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"setFromBufferAttribute(buffer, offset)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Sets the sphere from a flat array of positions (like BufferAttribute) with optional offset"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"translate(offset)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Moves the sphere by an offset vector"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"equals(sphere)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"boolean"})}),(0,d.jsx)(r.td,{children:"Checks if this sphere equals another (same center and radius)"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"getBoundingBox(target)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"UeBox3"})}),(0,d.jsx)(r.td,{children:"Returns the minimal bounding box enclosing this sphere"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"intersectsBox(box)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"boolean"})}),(0,d.jsxs)(r.td,{children:["Returns ",(0,d.jsx)(r.code,{children:"true"})," if the sphere intersects a given box"]})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"intersectsPlane(plane)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"boolean"})}),(0,d.jsxs)(r.td,{children:["Returns ",(0,d.jsx)(r.code,{children:"true"})," if the sphere intersects a given plane"]})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"intersectsSphere(sphere)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"boolean"})}),(0,d.jsxs)(r.td,{children:["Returns ",(0,d.jsx)(r.code,{children:"true"})," if this sphere intersects another sphere"]})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"union(sphere)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Expands this sphere to be the smallest sphere that contains both this and the given sphere"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"toJSON()"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Object"})}),(0,d.jsx)(r.td,{children:"Returns a JSON representation of the sphere"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"fromJSON(data)"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"self"})}),(0,d.jsx)(r.td,{children:"Loads sphere from JSON"})]})]})]})]})}function x(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,d.jsx)(r,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}},8453:(e,r,s)=>{s.d(r,{R:()=>i,x:()=>c});var t=s(6540);const d={},n=t.createContext(d);function i(e){const r=t.useContext(n);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),t.createElement(n.Provider,{value:r},e.children)}}}]);