"use strict";(globalThis.webpackChunkuniquemath=globalThis.webpackChunkuniquemath||[]).push([[775],{8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>o});var r=i(6540);const s={},d=r.createContext(s);function c(e){const n=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(d.Provider,{value:n},e.children)}},9093:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Functions/Transform","title":"Transform","description":"Array-based structure for managing position, rotation (quaternion), and scale, with performance-oriented methods and zero allocations where possible.","source":"@site/docs/Functions/Transform.md","sourceDirName":"Functions","slug":"/Functions/Transform","permalink":"/unique-math/docs/Functions/Transform","draft":false,"unlisted":false,"editUrl":"https://github.com/manuel-di-iorio/unique-math/tree/main/docs/docs/Functions/Transform.md","tags":[],"version":"current","sidebarPosition":17,"frontMatter":{"sidebar_position":17},"sidebar":"documentationSidebar","previous":{"title":"Ray","permalink":"/unique-math/docs/Functions/Ray"},"next":{"title":"Plane","permalink":"/unique-math/docs/Functions/Plane"}}');var s=i(4848),d=i(8453);const c={sidebar_position:17},o="Transform",t={},l=[{value:"Overview",id:"overview",level:2},{value:"Creation",id:"creation",level:2},{value:"Matrix API",id:"matrix-api",level:2},{value:"Translation",id:"translation",level:2},{value:"Rotation",id:"rotation",level:2},{value:"Scale",id:"scale",level:2},{value:"Space Conversion",id:"space-conversion",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"transform",children:"Transform"})}),"\n",(0,s.jsx)(n.p,{children:"Array-based structure for managing position, rotation (quaternion), and scale, with performance-oriented methods and zero allocations where possible."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Type: ",(0,s.jsx)(n.code,{children:"new Transform(data?)"})]}),"\n",(0,s.jsx)(n.li,{children:"Internals:"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"position"}),": ",(0,s.jsx)(n.code,{children:"vec3"})," as array ",(0,s.jsx)(n.code,{children:"[x, y, z]"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rotation"}),": quaternion as array ",(0,s.jsx)(n.code,{children:"[x, y, z, w]"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"scale"}),": ",(0,s.jsx)(n.code,{children:"vec3"})," as array ",(0,s.jsx)(n.code,{children:"[x, y, z]"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"up"}),": up vector (default ",(0,s.jsx)(n.code,{children:"[0, 0, -1]"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"matrix"}),": local ",(0,s.jsx)(n.code,{children:"mat4"})," (16-element array, column-major)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"matrixWorld"}),": ",(0,s.jsx)(n.code,{children:"mat4"})," in world space"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"parent"}),": reference to the parent Transform (optional)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"children"}),": array of children (Transform)"]}),"\n",(0,s.jsx)(n.li,{children:"Matrix Updates:"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"matrixAutoUpdate"}),": automatically updates the local matrix"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"matrixWorldAutoUpdate"}),": automatically updates the world matrix"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"matrixWorldNeedsUpdate"}),": internal flag to request The update"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Dependencies: Uses the array-based functions ",(0,s.jsx)(n.code,{children:"vec3_*"}),", ",(0,s.jsx)(n.code,{children:"quat_*"}),", ",(0,s.jsx)(n.code,{children:"mat4_*"})," present in the project."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"creation",children:"Creation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"new Transform(data?)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.position"}),": ",(0,s.jsx)(n.code,{children:"[x, y, z]"})," optional"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.rotation"}),": ",(0,s.jsx)(n.code,{children:"[x, y, z, w]"})," optional (identity if not passed)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.scale"}),": ",(0,s.jsx)(n.code,{children:"[x, y, z]"})," optional (default ",(0,s.jsx)(n.code,{children:"[1,1,1]"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.up"}),": ",(0,s.jsx)(n.code,{children:"[x, y, z]"})," optional (default ",(0,s.jsx)(n.code,{children:"[0,0,-1]"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.matrix"}),", ",(0,s.jsx)(n.code,{children:"data.matrixWorld"}),": optional 4x4 matrices"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.parent"}),", ",(0,s.jsx)(n.code,{children:"data.children"}),": optional"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data.matrixAutoUpdate"}),", ",(0,s.jsx)(n.code,{children:"data.matrixWorldAutoUpdate"}),": optional Booleans"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"matrix-api",children:"Matrix API"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"updateMatrix()"}),"\nRecomposes the local matrix from ",(0,s.jsx)(n.code,{children:"position"}),", ",(0,s.jsx)(n.code,{children:"rotation"}),", ",(0,s.jsx)(n.code,{children:"scale"})," using ",(0,s.jsx)(n.code,{children:"mat4_compose"}),". Set ",(0,s.jsx)(n.code,{children:"matrixWorldNeedsUpdate"})," = true."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"updateMatrixWorld(force = false)"}),"\nUpdates the ",(0,s.jsx)(n.code,{children:"matrixWorld"}),". If a ",(0,s.jsx)(n.code,{children:"parent"})," exists, multiplies ",(0,s.jsx)(n.code,{children:"matrix * parent.matrixWorld"})," (column-major order consistent with ",(0,s.jsx)(n.code,{children:"mat4_multiply_matrices"}),"). Propagates to ",(0,s.jsx)(n.code,{children:"children"})," if ",(0,s.jsx)(n.code,{children:"force"})," or requested."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"updateWorldMatrix(updateParents = false, updateChildren = false)"}),"\nVariant that allows updating by going back to the parent and/or propagating to the children, respecting ",(0,s.jsx)(n.code,{children:"matrixAutoUpdate"})," and ",(0,s.jsx)(n.code,{children:"matrixWorldAutoUpdate"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"applyMatrix4(mat4)"}),"\nPost-multiplies ",(0,s.jsx)(n.code,{children:"matrix"})," by ",(0,s.jsx)(n.code,{children:"mat4"})," and decomposes again into ",(0,s.jsx)(n.code,{children:"position"}),", ",(0,s.jsx)(n.code,{children:"rotation"}),", ",(0,s.jsx)(n.code,{children:"scale"})," with ",(0,s.jsx)(n.code,{children:"mat4_decompose"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"applyQuaternion(quat)"}),"\nCombines the current rotation with ",(0,s.jsx)(n.code,{children:"quat"})," via ",(0,s.jsx)(n.code,{children:"quat_multiply"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getWorldPosition(target)"}),"\nWrites the position vector extracted from ",(0,s.jsx)(n.code,{children:"matrixWorld"})," (",(0,s.jsx)(n.code,{children:"vec3_set_from_matrix_position"}),") to ",(0,s.jsx)(n.code,{children:"target"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getWorldQuaternion(target)"}),"\nDecomposes ",(0,s.jsx)(n.code,{children:"matrixWorld"})," and returns the world quaternion to ",(0,s.jsx)(n.code,{children:"target"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getWorldScale(target)"}),"\nDecomposes ",(0,s.jsx)(n.code,{children:"matrixWorld"})," and returns the world scale to ",(0,s.jsx)(n.code,{children:"target"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getWorldDirection(target?)"}),"\nTransforms the local ",(0,s.jsx)(n.code,{children:"up"})," to the world direction using ",(0,s.jsx)(n.code,{children:"vec3_transform_direction(matrixWorld)"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"translation",children:"Translation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"setPosition(x, y, z)"}),"\nSets ",(0,s.jsx)(n.code,{children:"position"})," directly."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"translateOnAxis(axis, distance)"}),"\nMoves along ",(0,s.jsx)(n.code,{children:"axis"})," (in object space); ",(0,s.jsx)(n.code,{children:"axis"})," is rotated by the current quaternion and then scaled by ",(0,s.jsx)(n.code,{children:"distance"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"translate(x, y, z)"}),"\nAdds the given vector to ",(0,s.jsx)(n.code,{children:"position"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"translateX(value)"}),", ",(0,s.jsx)(n.code,{children:"translateY(value)"}),", ",(0,s.jsx)(n.code,{children:"translateZ(value)"}),"\nIncrements the corresponding component of ",(0,s.jsx)(n.code,{children:"position"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"rotation",children:"Rotation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"lookAtVec(target)"}),"\nConstructs a look-at ",(0,s.jsx)(n.code,{children:"mat4"})," with ",(0,s.jsx)(n.code,{children:"mat4_look_at(position, target, up)"})," and updates ",(0,s.jsx)(n.code,{children:"rotation"})," via ",(0,s.jsx)(n.code,{children:"quat_set_from_rotation_matrix"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"lookAt(x, y, z)"}),"\nVariant that accepts numeric coordinates."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"setRotation(x, y, z)"}),"\nSets ",(0,s.jsx)(n.code,{children:"rotation"})," from Euler (degrees) via ",(0,s.jsx)(n.code,{children:"quat_set_from_euler"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"setRotationFromMatrix(mat)"}),"\nSets ",(0,s.jsx)(n.code,{children:"rotation"})," by reading the upper 3\xd73 of ",(0,s.jsx)(n.code,{children:"mat"})," (",(0,s.jsx)(n.code,{children:"quat_set_from_rotation_matrix"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"setRotationFromQuaternion(quat)"}),"\nCopies the quaternion passed into ",(0,s.jsx)(n.code,{children:"rotation"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rotate(x, y, z)"}),"\nConverts Euler to a temporary quaternion and combines it with ",(0,s.jsx)(n.code,{children:"rotation"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rotateX(value)"}),", ",(0,s.jsx)(n.code,{children:"rotateY(value)"}),", ",(0,s.jsx)(n.code,{children:"rotateZ(value)"}),"\nRotate locally around the axes via ",(0,s.jsx)(n.code,{children:"quat_set_from_axis_angle"})," and ",(0,s.jsx)(n.code,{children:"quat_multiply"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rotateOnAxis(axis, angle)"}),"\nRotates around an arbitrary local axis."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rotateOnWorldAxis(axis, angle)"}),"\nRotates around a world axis (use ",(0,s.jsx)(n.code,{children:"quat_premultiply"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"scale",children:"Scale"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"setScale(x, y, z)"}),"\nSets ",(0,s.jsx)(n.code,{children:"scale"})," directly."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"scaleX(value)"}),", ",(0,s.jsx)(n.code,{children:"scaleY(value)"}),", ",(0,s.jsx)(n.code,{children:"scaleZ(value)"}),"\nIncrements the corresponding component of ",(0,s.jsx)(n.code,{children:"scale"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"space-conversion",children:"Space Conversion"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"localToWorld(vec)"}),"\nApplies ",(0,s.jsx)(n.code,{children:"matrixWorld"})," to the ",(0,s.jsx)(n.code,{children:"vec"})," vector (as position, with w=1) using ",(0,s.jsx)(n.code,{children:"vec3_apply_matrix4"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"worldToLocal(vec)"}),"\nApplies the inverse of ",(0,s.jsx)(n.code,{children:"matrixWorld"})," to ",(0,s.jsx)(n.code,{children:"vec"})," to obtain local coordinates."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);