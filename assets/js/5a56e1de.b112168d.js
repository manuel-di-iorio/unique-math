"use strict";(globalThis.webpackChunkuniquemath=globalThis.webpackChunkuniquemath||[]).push([[179],{4082:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>x,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Struct/UeBox2","title":"UeBox2","description":"A 2D axis-aligned bounding box (AABB) class that defines a rectangle using minimum and maximum Vector2 corners. Useful for spatial partitioning, collision checks, and geometric operations in 2D space.","source":"@site/docs/Struct/UeBox2.md","sourceDirName":"Struct","slug":"/Struct/UeBox2","permalink":"/unique-math/docs/Struct/UeBox2","draft":false,"unlisted":false,"editUrl":"https://github.com/manuel-di-iorio/unique-math/tree/main/docs/docs/Struct/UeBox2.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"documentationSidebar","previous":{"title":"UeRay","permalink":"/unique-math/docs/Struct/UeRay"},"next":{"title":"UeBox3","permalink":"/unique-math/docs/Struct/UeBox3"}}');var d=n(4848),s=n(8453);const r={sidebar_position:9},c=void 0,o={},l=[{value:"Constructor",id:"constructor",level:2},{value:"Data parameters",id:"data-parameters",level:3},{value:"Methods",id:"methods",level:2}];function h(e){const t={code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.p,{children:"A 2D axis-aligned bounding box (AABB) class that defines a rectangle using minimum and maximum Vector2 corners. Useful for spatial partitioning, collision checks, and geometric operations in 2D space."}),"\n",(0,d.jsx)(t.hr,{}),"\n",(0,d.jsx)(t.h2,{id:"constructor",children:"Constructor"}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-js",children:"new UeBox2(min = new UeVector2(infinity, infinity), max = new UeVector2(-infinity, -infinity))\n"})}),"\n",(0,d.jsx)(t.h3,{id:"data-parameters",children:"Data parameters"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Name"}),(0,d.jsx)(t.th,{children:"Type"}),(0,d.jsx)(t.th,{children:"Default"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"min"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"UeVector2"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"(infinity, infinity)"})}),(0,d.jsx)(t.td,{children:"Minimum corner of the box"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"max"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"UeVector2"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"(-infinity, -infinity)"})}),(0,d.jsx)(t.td,{children:"Maximum corner of the box"})]})]})]}),"\n",(0,d.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Method"}),(0,d.jsx)(t.th,{children:"Returns"}),(0,d.jsx)(t.th,{children:"Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"clone()"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"UeBox2"})}),(0,d.jsx)(t.td,{children:"Returns a copy of this box"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"set(min, max)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Sets the min and max corners of the box"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"makeEmpty()"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Empties the box so it contains no points"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"isEmpty()"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"boolean"})}),(0,d.jsxs)(t.td,{children:["Returns ",(0,d.jsx)(t.code,{children:"true"})," if the box is empty (max < min)"]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"setFromPoints(points)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Expands the box to fit a set of 2D points (array of UeVector2 or flat array [x0,y0,x1,y1,...])"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"setFromBufferAttribute(buffer, offset)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Sets the box from a flat array of positions (like BufferAttribute) with optional offset"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"setFromCenterAndSize(center, size)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Builds the box using a center point and size"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"copy(box)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Copies the bounds from another box"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"expandByPoint(point)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Expands the box to include a given point (UeVector2)"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"expandByScalar(scalar)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Expands the box in all directions by a scalar"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"expandByVector(vec)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Expands the box in all directions by a vector"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"containsPoint(point)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"boolean"})}),(0,d.jsxs)(t.td,{children:["Returns ",(0,d.jsx)(t.code,{children:"true"})," if the point is inside the box (point: UeVector2)"]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"containsBox(box)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"boolean"})}),(0,d.jsxs)(t.td,{children:["Returns ",(0,d.jsx)(t.code,{children:"true"})," if the given box is fully inside this box"]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"intersect(box)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Updates this box to be the intersection of itself and another"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"intersectsBox(box)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"boolean"})}),(0,d.jsxs)(t.td,{children:["Returns ",(0,d.jsx)(t.code,{children:"true"})," if the two boxes intersect"]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"union(box)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Merges this box with another, expanding the bounds"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getCenter(target)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"UeVector2"})}),(0,d.jsx)(t.td,{children:"Returns the center point of the box"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getSize(target)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"UeVector2"})}),(0,d.jsx)(t.td,{children:"Returns the size (width, height) of the box"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"getParameter(point, target)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"UeVector2"})}),(0,d.jsx)(t.td,{children:"Returns normalized coordinates of a point relative to the box (0..1) (point: UeVector2)"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"clampPoint(point, target)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"UeVector2"})}),(0,d.jsx)(t.td,{children:"Clamps a point to stay within the box limits (point: UeVector2)"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"distanceToPoint(point)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"number"})}),(0,d.jsx)(t.td,{children:"Returns distance from point to the box (0 if point is inside) (point: UeVector2)"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"translate(offset)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"self"})}),(0,d.jsx)(t.td,{children:"Moves the box by an offset"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"equals(box)"})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"boolean"})}),(0,d.jsx)(t.td,{children:"Checks whether this box is equal to another (min and max match)"})]})]})]})]})}function x(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var i=n(6540);const d={},s=i.createContext(d);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);