"use strict";(globalThis.webpackChunkuniquemath=globalThis.webpackChunkuniquemath||[]).push([[566],{584:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>x,frontMatter:()=>r,metadata:()=>d,toc:()=>l});const d=JSON.parse('{"id":"Struct/UeBox3","title":"UeBox3","description":"A 3D axis-aligned bounding box (AABB) class that defines a cuboid using minimum and maximum Vector3 corners. Useful for spatial partitioning, collision detection, and geometric operations in 3D space.","source":"@site/docs/Struct/UeBox3.md","sourceDirName":"Struct","slug":"/Struct/UeBox3","permalink":"/unique-math/docs/Struct/UeBox3","draft":false,"unlisted":false,"editUrl":"https://github.com/manuel-di-iorio/unique-math/tree/main/docs/docs/Struct/UeBox3.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"documentationSidebar","previous":{"title":"UeBox2","permalink":"/unique-math/docs/Struct/UeBox2"},"next":{"title":"UeSphere","permalink":"/unique-math/docs/Struct/UeSphere"}}');var i=n(4848),s=n(8453);const r={sidebar_position:10},c=void 0,o={},l=[{value:"Constructor",id:"constructor",level:2},{value:"Data parameters",id:"data-parameters",level:3},{value:"Methods",id:"methods",level:2}];function h(e){const t={code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"A 3D axis-aligned bounding box (AABB) class that defines a cuboid using minimum and maximum Vector3 corners. Useful for spatial partitioning, collision detection, and geometric operations in 3D space."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"constructor",children:"Constructor"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"new UeBox3(min = new UeVector3(infinity, infinity, infinity), max = new UeVector3(-infinity, -infinity, -infinity))\n"})}),"\n",(0,i.jsx)(t.h3,{id:"data-parameters",children:"Data parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Name"}),(0,i.jsx)(t.th,{children:"Type"}),(0,i.jsx)(t.th,{children:"Default"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"min"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UeVector3"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"(infinity, infinity, infinity)"})}),(0,i.jsx)(t.td,{children:"Minimum corner of the box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"max"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UeVector3"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"(-infinity, -infinity, -infinity)"})}),(0,i.jsx)(t.td,{children:"Maximum corner of the box"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Method"}),(0,i.jsx)(t.th,{children:"Returns"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"clone()"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UeBox3"})}),(0,i.jsx)(t.td,{children:"Returns a copy of this box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"set(min, max)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Sets the min and max corners of the box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"setFromCenterAndSize(center, size)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Builds the box using a center point and size"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"setFromPoints(points)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Expands the box to fit a set of 3D points (array of UeVector3 or flat array [x0,y0,z0,x1,y1,z1,...])"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"setFromBufferAttribute(buffer, offset)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Sets the box from a flat array of positions (like BufferAttribute) with optional offset"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"setFromObject(object, precise)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Sets the box from an object's geometry (optionally precise)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"copy(box)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Copies the bounds from another box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"makeEmpty()"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Empties the box so it contains no points"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"isEmpty()"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsxs)(t.td,{children:["Returns ",(0,i.jsx)(t.code,{children:"true"})," if the box is empty (max < min)"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"expandByPoint(point)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Expands the box to include a given point (point: UeVector3)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"expandByScalar(scalar)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Expands the box in all directions by a scalar"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"expandByVector(vec)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Expands the box in all directions by a vector"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"expandByObject(object, precise)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Expands the box to include an object's bounding box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"containsPoint(point)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsxs)(t.td,{children:["Returns ",(0,i.jsx)(t.code,{children:"true"})," if the point is inside the box (point: UeVector3)"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"containsBox(box)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsxs)(t.td,{children:["Returns ",(0,i.jsx)(t.code,{children:"true"})," if the given box is fully inside this box"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"intersect(box)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Updates this box to be the intersection of itself and another"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"intersectsBox(box)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsxs)(t.td,{children:["Returns ",(0,i.jsx)(t.code,{children:"true"})," if the two boxes intersect"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"intersectsSphere(sphere)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsxs)(t.td,{children:["Returns ",(0,i.jsx)(t.code,{children:"true"})," if the box intersects a given sphere"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"intersectsPlane(plane)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsxs)(t.td,{children:["Returns ",(0,i.jsx)(t.code,{children:"true"})," if the box intersects a given plane"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"getCenter(target)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UeVector3"})}),(0,i.jsx)(t.td,{children:"Returns the center point of the box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"getSize(target)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UeVector3"})}),(0,i.jsx)(t.td,{children:"Returns the size (width, height, depth) of the box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"getParameter(point, target)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UeVector3"})}),(0,i.jsx)(t.td,{children:"Returns normalized coordinates of a point relative to the box (0..1) (point: UeVector3)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"applyMatrix4(matrix)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Applies a 4x4 transformation matrix to the box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"translate(offset)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Moves the box by an offset"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"equals(box)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsx)(t.td,{children:"Checks whether this box is equal to another (min and max match)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"clampPoint(point, target)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"UeVector3"})}),(0,i.jsx)(t.td,{children:"Clamps a point to stay within the box limits (point: UeVector3)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"distanceToPoint(point)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"number"})}),(0,i.jsx)(t.td,{children:"Returns distance from point to the box (0 if point is inside) (point: UeVector3)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"getBoundingSphere(target)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"Object"})}),(0,i.jsx)(t.td,{children:"Calculates the bounding sphere that encloses the box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"union(box)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Merges this box with another, expanding the bounds"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"toJSON()"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"Object"})}),(0,i.jsx)(t.td,{children:"Returns a JSON representation of the box"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"fromJSON(data)"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"self"})}),(0,i.jsx)(t.td,{children:"Loads the box from JSON"})]})]})]})]})}function x(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var d=n(6540);const i={},s=d.createContext(i);function r(e){const t=d.useContext(s);return d.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),d.createElement(s.Provider,{value:t},e.children)}}}]);