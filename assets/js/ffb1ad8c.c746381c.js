"use strict";(globalThis.webpackChunkuniquemath=globalThis.webpackChunkuniquemath||[]).push([[472],{3182:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>x,frontMatter:()=>r,metadata:()=>d,toc:()=>h});const d=JSON.parse('{"id":"Math/UeBox2","title":"UeBox2","description":"A 2D axis-aligned bounding box (AABB) class that defines a rectangle using minimum and maximum Vector2 corners. Useful for spatial partitioning, collision checks, and geometric operations in 2D space.","source":"@site/docs/Math/UeBox2.md","sourceDirName":"Math","slug":"/Math/UeBox2","permalink":"/unique-math/docs/Math/UeBox2","draft":false,"unlisted":false,"editUrl":"https://github.com/manuel-di-iorio/unique-math/tree/main/docs/docs/Math/UeBox2.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"documentationSidebar","previous":{"title":"UeRay","permalink":"/unique-math/docs/Math/UeRay"},"next":{"title":"UeBox3","permalink":"/unique-math/docs/Math/UeBox3"}}');var i=t(4848),s=t(8453);const r={sidebar_position:9},c=void 0,o={},h=[{value:"Constructor",id:"constructor",level:2},{value:"Data parameters",id:"data-parameters",level:3},{value:"Methods",id:"methods",level:2}];function l(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"A 2D axis-aligned bounding box (AABB) class that defines a rectangle using minimum and maximum Vector2 corners. Useful for spatial partitioning, collision checks, and geometric operations in 2D space."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"new UeBox2(min = new UeVector2(infinity, infinity), max = new UeVector2(-infinity, -infinity))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"data-parameters",children:"Data parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"min"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"UeVector2"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(infinity, infinity)"})}),(0,i.jsx)(n.td,{children:"Minimum corner of the box"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"max"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"UeVector2"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(-infinity, -infinity)"})}),(0,i.jsx)(n.td,{children:"Maximum corner of the box"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Method"}),(0,i.jsx)(n.th,{children:"Returns"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"clone()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"UeBox2"})}),(0,i.jsx)(n.td,{children:"Returns a copy of this box"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"set(min, max)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Sets the min and max corners of the box"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"makeEmpty()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Empties the box so it contains no points"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"isEmpty()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if the box is empty (max < min)"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"setFromPoints(points[])"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Expands the box to fit a set of 2D points"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"setFromCenterAndSize(center, size)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Builds the box using a center point and size"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"copy(box)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Copies the bounds from another box"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"expandByPoint(point)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Expands the box to include a given point"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"expandByScalar(scalar)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Expands the box in all directions by a scalar"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"expandByVector(vec)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Expands the box in all directions by a vector"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"containsPoint(point)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if the point is inside the box"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"containsBox(box)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if the given box is fully inside this box"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"intersect(box)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Updates this box to be the intersection of itself and another"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"intersectsBox(box)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if the two boxes intersect"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"union(box)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Merges this box with another, expanding the bounds"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"getCenter(target)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"UeVector2"})}),(0,i.jsx)(n.td,{children:"Returns the center point of the box"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"getSize(target)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"UeVector2"})}),(0,i.jsx)(n.td,{children:"Returns the size (width, height) of the box"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"getParameter(point, target)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"UeVector2"})}),(0,i.jsx)(n.td,{children:"Returns normalized coordinates of a point relative to the box (0..1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"clampPoint(point, target)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"UeVector2"})}),(0,i.jsx)(n.td,{children:"Clamps a point to stay within the box limits"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"distanceToPoint(point)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"number"})}),(0,i.jsx)(n.td,{children:"Returns distance from point to the box (0 if point is inside)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"translate(offset)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"self"})}),(0,i.jsx)(n.td,{children:"Moves the box by an offset"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"equals(box)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsx)(n.td,{children:"Checks whether this box is equal to another (min and max match)"})]})]})]})]})}function x(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var d=t(6540);const i={},s=d.createContext(i);function r(e){const n=d.useContext(s);return d.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),d.createElement(s.Provider,{value:n},e.children)}}}]);